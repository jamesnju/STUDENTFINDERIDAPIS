// src/controllers/foundIDController.ts
import { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import { prisma } from '../conn/connection';

export const postFoundID = async (req: Request, res: Response) => {
    const { name, admissionNo, description } = req.body;
    //console.log("User ID (String):", req.body.userId); // Check the raw string from the request body
    const userId = parseInt(req.body.userId, 10);

 
    const imagePath = req.file ? `/tmp/${req.file.filename}` : null; // Use the file path stored in the tmp folder
        // Check the image path generated by Multer

    if (isNaN(userId) || !name || !admissionNo || !req.file) {
      res.status(400).json({ error: 'All fields are required' });
      return;
    }
console.log("File uploaded:", req.file); // This will show the file details, if it's uploaded correctly
    try {
      // Ensure user exists
      const user = await prisma.user.findUnique({ where: { id: userId } });
      if (!user) {
        res.status(404).json({ error: 'User not found' });
        return;
      }
  
      // Store only the image filename (with extension)
      const imageFileName = req.file.filename; // This is the filename with the extension
  
      // Create foundID entry
      const foundID = await prisma.foundID.create({
        data: {
          userId,
          name,
          location: "james",
          admissionNo,
          image: imageFileName, // Store the filename
          description,
        },
      });
  
      res.status(201).json({ message: 'DoundID created successfully', foundID, imagePath });
    } catch (error) {
      console.error('Error creating FoundID:', error);
      res.status(500).json({ error: 'Failed to create FoundID' });
    }
  };


// Update FoundID by ID
export const updateFoundID = async (req: Request, res: Response) => {
    const { id } = req.params;
    const { name, admissionNo, description } = req.body;
    console.log(name, admissionNo, description, "the submitted");
    const imagePath = req.file ? `/tmp/${req.file.filename}` : null; // Image path to store in DB
  
    try {
      // Find the FoundID by ID
      const foundID = await prisma.foundID.findUnique({ where: { id: parseInt(id) } });
      if (!foundID) {
        res.status(404).json({ error: 'FoundID not found' });
        return;
      }
  
      // Determine new image file name if provided, otherwise use the existing one
      const updatedImage = req.file?.filename || foundID.image;
  
      // Update the FoundID fields
      const updatedFoundID = await prisma.foundID.update({
        where: { id: parseInt(id) },
        data: {
          name: name || foundID.name, // Only update if the field is provided
          admissionNo: admissionNo || foundID.admissionNo, // Only update if the field is provided
          description: description || foundID.description, // Only update if the field is provided
          image: updatedImage, // Update image with the new filename or keep the old one
        },
      });
  
      res.status(200).json({
        message: 'FoundID updated successfully',
        updatedFoundID,
        imagePath: `tmp/${updatedImage}`, // Include the new image path in the response
      });
    } catch (error) {
      console.error('Error updating FoundID:', error);
      res.status(500).json({ error: 'Failed to update FoundID' });
    }
  };

  // Get FoundID by ID
  export const getFoundID = async (req: Request, res: Response) => {
    const { id } = req.params;
  
    try {
      // Find the FoundID by ID
      const foundID = await prisma.foundID.findUnique({ where: { id: parseInt(id) } });
      if (!foundID) {
        res.status(404).json({ error: 'FoundID not found' });
        return;
      }
  
      // Add the full image path
      const foundIDWithImagePath = {
        ...foundID,
        image: foundID.image ? `tmp/${foundID.image}` : null, // Ensure full path is returned
      };
  
      res.status(200).json({ foundID: foundIDWithImagePath });
    } catch (error) {
      console.error('Error fetching FoundID:', error);
      res.status(500).json({ error: 'Failed to fetch FoundID' });
    }
  };
  


// Get all foundIDs
export const getAllFoundIDs = async (req: Request, res: Response) => {
  try {
    // Fetch all FoundID records from the database
    const foundIDs = await prisma.foundID.findMany();
    if (foundIDs.length === 0) {
      res.status(404).json({ error: 'No FoundIDs found' });
      return;
    }

    // Map over each FoundID and add the full image path
    const foundIDsWithImagePaths = foundIDs.map((foundID) => ({
      ...foundID,
      image: foundID.image ? `tmp/${foundID.image}` : null, // Include image path (full URL)
    }));

    // Return all FoundID records with the full image path
    res.status(200).json({ foundIDs: foundIDsWithImagePaths });
  } catch (error) {
    console.error('Error fetching FoundIDs:', error);
    res.status(500).json({ error: 'Failed to fetch FoundIDs' });
  }
};

  // Delete FoundID by ID
export const deleteFoundID = async (req: Request, res: Response) => {
  const { id } = req.params;

  try {
    // Find the FoundID by ID
    const foundID = await prisma.foundID.findUnique({ where: { id: parseInt(id) } });
    if (!foundID) {
       res.status(404).json({ error: 'FoundID not found' });
       return;
    }

    // Delete the FoundID
    await prisma.foundID.delete({ where: { id: parseInt(id) } });

    // Return a success message
    res.status(200).json({ message: 'FoundID deleted successfully' });
  } catch (error) {
    console.error('Error deleting FoundID:', error);
    res.status(500).json({ error: 'Failed to delete FoundID' });
  }
};